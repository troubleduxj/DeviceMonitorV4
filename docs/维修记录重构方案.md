# 维修记录功能重构方案

## 1. 重构目标

### 主要目标
- 使后端API完全支持前端数据结构
- 统一前后端字段命名和数据格式
- 简化数据模型，提高开发效率
- 保持数据完整性和一致性

### 重构原则
- 以前端需求为准，后端完全适配
- 保持现有数据库数据不丢失
- 渐进式重构，确保系统稳定性
- 统一使用英文状态值和字段名

## 2. 数据结构对比分析

### 2.1 前端期望的数据结构
```javascript
{
  id: 1,
  device_id: 1,
  device_code: 'B001-00826',           // 需要从设备表关联获取
  device_type: 'welding',
  repair_date: '2025-01-01',
  repair_code: 'RP20250101001',
  repair_status: 'completed',          // 英文状态值
  priority: 'normal',                  // 英文优先级
  applicant: '胡春光',
  applicant_phone: '15567113573',
  applicant_dept: '加工一部',
  applicant_workshop: '组立车间',
  construction_unit: '前骏',
  is_fault: true,
  fault_reason: '操作不当',
  damage_category: '非正常损坏',
  fault_content: '无电流',
  fault_location: '综合线',
  repair_content: '综合线维修',
  parts_name: '',
  repairer: '刘德超',
  repair_start_time: '2025-01-01 08:00:00',
  repair_completion_date: '2025-01-01 16:00:00',
  repair_cost: 800.00,
  device_specific_data: {
    device_brand: '松下',
    device_model: 'YD-500ER2',
    device_spec: '7P',
    company: '恒力造船（大连）有限公司'
  },
  remarks: ''
}
```

### 2.2 当前数据库结构
```sql
-- t_device_repair_record 表结构
id: bigint (PK)
device_id: bigint (FK)
device_type: varchar
repair_date: date
repair_code: varchar
repair_status: varchar              -- 当前使用中文值
priority: varchar                   -- 当前使用中文值 '中'
applicant: varchar
applicant_phone: varchar
applicant_dept: varchar
applicant_workshop: varchar
construction_unit: varchar
is_fault: boolean
fault_reason: varchar
damage_category: varchar
fault_content: text
fault_location: varchar
repair_content: text
parts_name: varchar
repairer: varchar
repair_start_time: timestamp
repair_completion_date: date
repair_cost: numeric
device_specific_data: jsonb
remarks: text
attachments: jsonb
created_by: bigint
updated_by: bigint
created_at: timestamp
updated_at: timestamp
```

### 2.3 需要解决的问题

1. **缺少字段**：
   - `device_code` - 需要通过关联设备表获取

2. **状态值不一致**：
   - `priority`: 数据库存储 '中' → 前端期望 'normal'
   - `repair_status`: 需要统一英文状态值

3. **时间格式**：
   - 需要统一时间格式输出

## 3. 重构实施方案

### 3.1 阶段一：数据模型优化

#### 3.1.1 创建状态映射枚举
```python
class RepairStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class RepairPriority(str, Enum):
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"
```

#### 3.1.2 优化响应模型
```python
class DeviceRepairRecordResponse(BaseModel):
    # 基础字段
    id: int
    device_id: int
    device_code: str                    # 新增：从设备表关联获取
    device_type: str
    
    # 维修信息
    repair_date: date
    repair_code: Optional[str]
    repair_status: RepairStatus
    priority: RepairPriority
    
    # 申请人信息
    applicant: str
    applicant_phone: Optional[str]
    applicant_dept: Optional[str]
    applicant_workshop: Optional[str]
    construction_unit: Optional[str]
    
    # 故障信息
    is_fault: bool
    fault_reason: Optional[str]
    damage_category: Optional[str]
    fault_content: Optional[str]
    fault_location: Optional[str]
    
    # 维修详情
    repair_content: Optional[str]
    parts_name: Optional[str]
    repairer: Optional[str]
    repair_start_time: Optional[datetime]
    repair_completion_date: Optional[date]
    repair_cost: Optional[float]
    
    # 扩展数据
    device_specific_data: Optional[Dict[str, Any]]
    remarks: Optional[str]
    
    # 时间戳
    created_at: datetime
    updated_at: datetime
```

### 3.2 阶段二：API接口重构

#### 3.2.1 查询接口优化
```python
@router.get("/repair-records", response_model=PaginatedResponse[DeviceRepairRecordResponse])
async def get_repair_records(
    query: DeviceRepairRecordQuery = Depends(),
    current_user: User = Depends(get_current_user)
):
    """获取维修记录列表 - 完全适配前端数据结构"""
    
    # 构建查询，包含设备信息关联
    queryset = DeviceRepairRecord.select().join(DeviceInfo)
    
    # 应用筛选条件
    if query.device_id:
        queryset = queryset.where(DeviceRepairRecord.device_id == query.device_id)
    if query.repair_status:
        queryset = queryset.where(DeviceRepairRecord.repair_status == query.repair_status)
    # ... 其他筛选条件
    
    # 分页
    total = await queryset.count()
    records = await queryset.offset((query.page - 1) * query.page_size).limit(query.page_size)
    
    # 数据转换和状态映射
    result_data = []
    for record in records:
        device = await record.device
        
        # 状态值映射
        mapped_priority = map_priority_to_english(record.priority)
        mapped_status = map_status_to_english(record.repair_status)
        
        record_data = {
            **record.__dict__,
            'device_code': device.device_code,  # 添加设备编号
            'priority': mapped_priority,        # 映射优先级
            'repair_status': mapped_status,     # 映射状态
            'repair_start_time': format_datetime(record.repair_start_time),
            'repair_completion_date': format_date(record.repair_completion_date),
        }
        result_data.append(record_data)
    
    return PaginatedResponse(
        data=result_data,
        total=total,
        page=query.page,
        page_size=query.page_size
    )
```

#### 3.2.2 创建接口优化
```python
@router.post("/repair-records", response_model=DeviceRepairRecordResponse)
async def create_repair_record(
    record_data: DeviceRepairRecordCreate,
    current_user: User = Depends(get_current_user)
):
    """创建维修记录 - 支持前端完整数据结构"""
    
    # 验证设备是否存在
    device = await DeviceInfo.get_or_none(id=record_data.device_id)
    if not device:
        raise HTTPException(status_code=404, detail="设备不存在")
    
    # 生成维修单号（如果未提供）
    if not record_data.repair_code:
        record_data.repair_code = await generate_repair_code(
            device_type=record_data.device_type,
            repair_date=record_data.repair_date
        )
    
    # 状态值映射（前端传入英文，存储时保持英文）
    create_data = record_data.dict()
    create_data['created_by'] = current_user.id
    create_data['updated_by'] = current_user.id
    
    # 创建记录
    record = await DeviceRepairRecord.create(**create_data)
    
    # 返回完整数据（包含设备编号）
    return await format_repair_record_response(record)
```

### 3.3 阶段三：数据迁移

#### 3.3.1 状态值迁移脚本
```python
async def migrate_repair_record_status():
    """迁移维修记录状态值从中文到英文"""
    
    # 优先级映射
    priority_mapping = {
        '低': 'low',
        '中': 'normal', 
        '高': 'high',
        '紧急': 'urgent'
    }
    
    # 状态映射
    status_mapping = {
        '待处理': 'pending',
        '进行中': 'in_progress', 
        '已完成': 'completed',
        '已取消': 'cancelled'
    }
    
    # 批量更新优先级
    for chinese_val, english_val in priority_mapping.items():
        await DeviceRepairRecord.filter(priority=chinese_val).update(priority=english_val)
    
    # 批量更新状态
    for chinese_val, english_val in status_mapping.items():
        await DeviceRepairRecord.filter(repair_status=chinese_val).update(repair_status=english_val)
    
    print("状态值迁移完成")
```

### 3.4 阶段四：工具函数

#### 3.4.1 状态映射函数
```python
def map_priority_to_english(chinese_priority: str) -> str:
    """将中文优先级映射为英文"""
    mapping = {
        '低': 'low',
        '中': 'normal',
        '高': 'high', 
        '紧急': 'urgent'
    }
    return mapping.get(chinese_priority, chinese_priority)

def map_status_to_english(chinese_status: str) -> str:
    """将中文状态映射为英文"""
    mapping = {
        '待处理': 'pending',
        '进行中': 'in_progress',
        '已完成': 'completed', 
        '已取消': 'cancelled'
    }
    return mapping.get(chinese_status, chinese_status)

async def format_repair_record_response(record: DeviceRepairRecord) -> dict:
    """格式化维修记录响应数据"""
    device = await record.device
    
    return {
        'id': record.id,
        'device_id': record.device_id,
        'device_code': device.device_code,
        'device_type': record.device_type,
        'repair_date': record.repair_date.isoformat(),
        'repair_code': record.repair_code,
        'repair_status': map_status_to_english(record.repair_status),
        'priority': map_priority_to_english(record.priority),
        'applicant': record.applicant,
        'applicant_phone': record.applicant_phone,
        'applicant_dept': record.applicant_dept,
        'applicant_workshop': record.applicant_workshop,
        'construction_unit': record.construction_unit,
        'is_fault': record.is_fault,
        'fault_reason': record.fault_reason,
        'damage_category': record.damage_category,
        'fault_content': record.fault_content,
        'fault_location': record.fault_location,
        'repair_content': record.repair_content,
        'parts_name': record.parts_name,
        'repairer': record.repairer,
        'repair_start_time': record.repair_start_time.isoformat() if record.repair_start_time else None,
        'repair_completion_date': record.repair_completion_date.isoformat() if record.repair_completion_date else None,
        'repair_cost': float(record.repair_cost) if record.repair_cost else None,
        'device_specific_data': record.device_specific_data,
        'remarks': record.remarks,
        'created_at': record.created_at.isoformat(),
        'updated_at': record.updated_at.isoformat()
    }
```

## 4. 实施计划

### 第1步：准备工作（1天）
- [x] 分析现有数据结构
- [x] 设计新的API结构
- [ ] 创建状态映射枚举

### 第2步：后端重构（2天）
- [ ] 更新数据模型和响应结构
- [ ] 重构API接口实现
- [ ] 添加状态映射逻辑
- [ ] 实现数据格式化函数

### 第3步：数据迁移（0.5天）
- [ ] 执行状态值迁移脚本
- [ ] 验证数据完整性

### 第4步：测试验证（1天）
- [ ] API接口测试
- [ ] 前后端联调测试
- [ ] 数据一致性验证

### 第5步：前端对接（0.5天）
- [ ] 启用真实API调用
- [ ] 移除模拟数据逻辑
- [ ] 功能验证

## 5. 风险控制

### 数据安全
- 迁移前备份数据库
- 分步骤执行，可回滚
- 保留原始数据字段

### 兼容性
- 保持API接口向后兼容
- 渐进式替换模拟数据
- 充分测试各种场景

### 性能优化
- 优化数据库查询
- 添加必要的索引
- 实现数据缓存机制

## 6. 预期效果

### 开发效率提升
- 前后端数据结构完全一致
- 减少字段映射和转换逻辑
- 简化调试和维护工作

### 数据一致性
- 统一状态值和字段命名
- 完整的数据验证机制
- 清晰的数据流转过程

### 用户体验改善
- 真实数据展示
- 完整的CRUD功能
- 稳定的系统性能