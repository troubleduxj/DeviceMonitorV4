# DeviceMonitor 测试方案与用例

本文档提供了 DeviceMonitor 项目的完整测试方案，包括测试策略、测试结构、运行方法、测试用例设计和最佳实践。

## 目录

- [测试策略](#测试策略)
- [测试架构](#测试架构)
- [测试环境](#测试环境)
- [测试类型与用例](#测试类型与用例)
- [测试执行](#测试执行)
- [测试配置](#测试配置)
- [CI/CD 集成](#cicd-集成)
- [测试开发指南](#测试开发指南)
- [质量保证](#质量保证)
- [故障排除](#故障排除)
- [最佳实践](#最佳实践)

## 测试策略

### 测试目标

1. **功能验证**: 确保所有功能按预期工作
2. **性能保证**: 验证系统性能满足要求
3. **安全检测**: 确保系统安全性
4. **兼容性测试**: 验证多平台兼容性
5. **回归测试**: 防止新功能破坏现有功能

### 测试原则

- **测试金字塔**: 单元测试 > 集成测试 > 端到端测试
- **测试隔离**: 每个测试独立运行，互不影响
- **快速反馈**: 优先运行快速测试，慢速测试分离
- **自动化优先**: 尽可能自动化所有测试
- **持续集成**: 每次代码提交都触发测试

### 测试覆盖率目标

- **代码覆盖率**: ≥ 85%
- **分支覆盖率**: ≥ 80%
- **API 覆盖率**: 100%
- **核心功能覆盖率**: 100%

## 测试架构

### 测试目录结构

```
tests/
├── conftest.py              # 测试配置和夹具
├── test_config.py           # 测试配置文件
├── test_basic.py            # 基础功能测试
├── test_api_endpoints.py    # API 端点测试
├── test_database.py         # 数据库测试
├── test_integration.py      # 集成测试
├── unit/                    # 单元测试目录
│   ├── test_models.py       # 模型测试
│   ├── test_services.py     # 服务测试
│   └── test_utils.py        # 工具函数测试
├── integration/             # 集成测试目录
│   ├── test_workflows.py    # 工作流测试
│   └── test_external_apis.py # 外部API测试
├── performance/             # 性能测试目录
│   ├── test_load.py         # 负载测试
│   └── test_stress.py       # 压力测试
├── security/                # 安全测试目录
│   ├── test_auth.py         # 认证测试
│   └── test_permissions.py  # 权限测试
├── fixtures/                # 测试数据目录
│   ├── sample_data.json     # 示例数据
│   └── test_files/          # 测试文件
├── logs/                    # 测试日志
├── temp/                    # 临时文件
└── reports/                 # 测试报告
```

### 配置文件

- `pytest.ini` - pytest 配置
- `.coveragerc` - 代码覆盖率配置
- `requirements-test.txt` - 测试依赖
- `conftest.py` - 测试夹具和配置

## 测试环境

### 环境分类

1. **本地开发环境**
   - 使用 SQLite 内存数据库
   - 模拟外部服务
   - 快速反馈

2. **CI/CD 环境**
   - 使用 PostgreSQL 数据库
   - Redis 缓存服务
   - 完整的服务依赖

3. **集成测试环境**
   - 接近生产环境配置
   - 真实的外部服务
   - 完整的数据流

### 环境变量配置

```bash
# 测试环境变量
TESTING=1
DATABASE_URL=sqlite:///test.db
REDIS_URL=redis://localhost:6379/1
SECRET_KEY=test-secret-key-for-testing-only
DEBUG=1
LOG_LEVEL=DEBUG
```

## 测试类型与用例

### 1. 单元测试 (Unit Tests)

**目标**: 测试单个函数或类的功能

**用例设计**:

#### 模型测试
```python
@pytest.mark.unit
class TestUserModel:
    """用户模型测试"""
    
    def test_create_user(self, db_session):
        """测试创建用户"""
        user = User(username="test", email="test@example.com")
        db_session.add(user)
        db_session.commit()
        assert user.id is not None
        assert user.username == "test"
    
    def test_user_password_hash(self):
        """测试密码哈希"""
        user = User(username="test")
        user.set_password("password123")
        assert user.check_password("password123")
        assert not user.check_password("wrong_password")
```

#### 服务测试
```python
@pytest.mark.unit
class TestUserService:
    """用户服务测试"""
    
    def test_create_user_service(self, mock_db):
        """测试用户创建服务"""
        service = UserService(mock_db)
        user_data = {"username": "test", "email": "test@example.com"}
        user = service.create_user(user_data)
        assert user.username == "test"
```

**运行命令**:
```bash
pytest tests/ -m "unit" -v
make test-unit
scripts/run-tests.bat unit
```

### 2. API 测试 (API Tests)

**目标**: 测试 REST API 端点的功能

**用例设计**:

#### 认证API测试
```python
@pytest.mark.api
@pytest.mark.asyncio
class TestAuthAPI:
    """认证API测试"""
    
    async def test_login_success(self, async_client, admin_user):
        """测试登录成功"""
        response = await async_client.post("/api/auth/login", json={
            "username": "admin",
            "password": "admin123"
        })
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert "token_type" in data
    
    async def test_login_invalid_credentials(self, async_client):
        """测试登录失败"""
        response = await async_client.post("/api/auth/login", json={
            "username": "invalid",
            "password": "invalid"
        })
        assert response.status_code == 401
```

#### 用户管理API测试
```python
@pytest.mark.api
@pytest.mark.asyncio
class TestUserAPI:
    """用户管理API测试"""
    
    async def test_get_users(self, async_client, auth_headers):
        """测试获取用户列表"""
        response = await async_client.get(
            "/api/users",
            headers=auth_headers
        )
        assert response.status_code == 200
        data = response.json()
        assert "items" in data
        assert "total" in data
    
    async def test_create_user(self, async_client, auth_headers):
        """测试创建用户"""
        user_data = {
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "password123"
        }
        response = await async_client.post(
            "/api/users",
            json=user_data,
            headers=auth_headers
        )
        assert response.status_code == 201
        data = response.json()
        assert data["username"] == "newuser"
```

**运行命令**:
```bash
pytest tests/ -m "api" -v
make test-api
scripts/run-tests.bat api
```

### 3. 数据库测试 (Database Tests)

**目标**: 测试数据库连接、模型和查询

**用例设计**:

#### 数据库连接测试
```python
@pytest.mark.database
class TestDatabaseConnection:
    """数据库连接测试"""
    
    def test_postgresql_connection(self):
        """测试PostgreSQL连接"""
        from app.core.database import get_db_session
        session = next(get_db_session())
        result = session.execute(text("SELECT 1"))
        assert result.scalar() == 1
    
    def test_tdengine_connection(self, mock_tdengine):
        """测试TDengine连接"""
        connector = mock_tdengine
        result = connector.execute("SELECT SERVER_STATUS()")
        assert result is not None
```

#### 模型关系测试
```python
@pytest.mark.database
class TestModelRelationships:
    """模型关系测试"""
    
    def test_user_department_relationship(self, db_session):
        """测试用户部门关系"""
        dept = Department(name="IT部门")
        user = User(username="test", department=dept)
        db_session.add_all([dept, user])
        db_session.commit()
        
        assert user.department.name == "IT部门"
        assert user in dept.users
```

**运行命令**:
```bash
pytest tests/ -m "database" -v
make test-db
scripts/run-tests.bat database
```

### 4. 集成测试 (Integration Tests)

**目标**: 测试多个组件之间的交互

**用例设计**:

#### 用户管理工作流测试
```python
@pytest.mark.integration
@pytest.mark.asyncio
class TestUserManagementWorkflow:
    """用户管理工作流测试"""
    
    async def test_complete_user_lifecycle(self, async_client, auth_headers):
        """测试完整的用户生命周期"""
        # 1. 创建用户
        user_data = {
            "username": "testuser",
            "email": "test@example.com",
            "password": "password123"
        }
        create_response = await async_client.post(
            "/api/users",
            json=user_data,
            headers=auth_headers
        )
        assert create_response.status_code == 201
        user_id = create_response.json()["id"]
        
        # 2. 获取用户详情
        get_response = await async_client.get(
            f"/api/users/{user_id}",
            headers=auth_headers
        )
        assert get_response.status_code == 200
        
        # 3. 更新用户
        update_data = {"email": "updated@example.com"}
        update_response = await async_client.put(
            f"/api/users/{user_id}",
            json=update_data,
            headers=auth_headers
        )
        assert update_response.status_code == 200
        
        # 4. 删除用户
        delete_response = await async_client.delete(
            f"/api/users/{user_id}",
            headers=auth_headers
        )
        assert delete_response.status_code == 204
```

#### 设备监控工作流测试
```python
@pytest.mark.integration
@pytest.mark.slow
class TestDeviceMonitoringWorkflow:
    """设备监控工作流测试"""
    
    async def test_device_data_collection_and_alert(self, async_client, auth_headers):
        """测试设备数据收集和告警"""
        # 1. 创建设备
        device_data = {
            "name": "测试设备",
            "type": "sensor",
            "location": "机房A"
        }
        device_response = await async_client.post(
            "/api/devices",
            json=device_data,
            headers=auth_headers
        )
        assert device_response.status_code == 201
        device_id = device_response.json()["id"]
        
        # 2. 模拟数据上报
        sensor_data = {
            "device_id": device_id,
            "temperature": 85.5,  # 超过阈值
            "humidity": 60.0,
            "timestamp": datetime.utcnow().isoformat()
        }
        data_response = await async_client.post(
            "/api/device-data",
            json=sensor_data,
            headers=auth_headers
        )
        assert data_response.status_code == 201
        
        # 3. 检查告警生成
        alerts_response = await async_client.get(
            f"/api/alerts?device_id={device_id}",
            headers=auth_headers
        )
        assert alerts_response.status_code == 200
        alerts = alerts_response.json()["items"]
        assert len(alerts) > 0
        assert alerts[0]["type"] == "temperature_high"
```

**运行命令**:
```bash
pytest tests/ -m "integration" -v
make test-integration
scripts/run-tests.bat integration
```

### 5. 性能测试 (Performance Tests)

**目标**: 测试应用程序的性能和基准

**用例设计**:

#### API性能测试
```python
@pytest.mark.performance
class TestAPIPerformance:
    """API性能测试"""
    
    def test_user_list_performance(self, benchmark, async_client, auth_headers):
        """测试用户列表API性能"""
        async def get_users():
            response = await async_client.get(
                "/api/users",
                headers=auth_headers
            )
            return response
        
        result = benchmark(get_users)
        assert result.status_code == 200
    
    def test_concurrent_requests(self, async_client, auth_headers):
        """测试并发请求性能"""
        import asyncio
        
        async def make_request():
            return await async_client.get("/api/health")
        
        async def test_concurrent():
            tasks = [make_request() for _ in range(100)]
            responses = await asyncio.gather(*tasks)
            return responses
        
        responses = asyncio.run(test_concurrent())
        assert all(r.status_code == 200 for r in responses)
```

#### 数据库性能测试
```python
@pytest.mark.performance
class TestDatabasePerformance:
    """数据库性能测试"""
    
    def test_bulk_insert_performance(self, benchmark, db_session):
        """测试批量插入性能"""
        def bulk_insert():
            users = []
            for i in range(1000):
                user = User(
                    username=f"user_{i}",
                    email=f"user_{i}@example.com"
                )
                users.append(user)
            db_session.bulk_save_objects(users)
            db_session.commit()
        
        benchmark(bulk_insert)
```

**运行命令**:
```bash
pytest tests/ -m "performance" --benchmark-only
make test-performance
scripts/run-tests.bat performance
```

### 6. 安全测试 (Security Tests)

**目标**: 验证系统安全性

**用例设计**:

#### 认证安全测试
```python
@pytest.mark.security
class TestAuthSecurity:
    """认证安全测试"""
    
    async def test_jwt_token_expiration(self, async_client):
        """测试JWT令牌过期"""
        # 使用过期的令牌
        expired_token = "expired.jwt.token"
        headers = {"Authorization": f"Bearer {expired_token}"}
        
        response = await async_client.get(
            "/api/users/me",
            headers=headers
        )
        assert response.status_code == 401
    
    async def test_sql_injection_protection(self, async_client):
        """测试SQL注入防护"""
        malicious_input = "'; DROP TABLE users; --"
        response = await async_client.get(
            f"/api/users?search={malicious_input}"
        )
        # 应该正常处理，不会执行恶意SQL
        assert response.status_code in [200, 400]
```

#### 权限控制测试
```python
@pytest.mark.security
class TestPermissionControl:
    """权限控制测试"""
    
    async def test_admin_only_endpoint(self, async_client, regular_user_headers):
        """测试管理员专用端点"""
        response = await async_client.delete(
            "/api/users/1",
            headers=regular_user_headers
        )
        assert response.status_code == 403
    
    async def test_user_data_isolation(self, async_client, user1_headers, user2_headers):
        """测试用户数据隔离"""
        # 用户1不能访问用户2的数据
        response = await async_client.get(
            "/api/users/2/profile",
            headers=user1_headers
        )
        assert response.status_code == 403
```

## 测试执行

### 快速开始

#### 1. 安装测试依赖

```bash
# 使用 Make 命令
make install-test

# 或手动安装
pip install -r requirements.txt
pip install -r requirements-test.txt
```

#### 2. 运行所有测试

```bash
# 使用测试脚本（推荐）
# Windows
scripts\run-tests.bat

# Linux/macOS
bash scripts/run-tests.sh

# 使用 Make 命令
make test

# 直接使用 pytest
pytest tests/ -v
```

#### 3. 查看覆盖率报告

```bash
# 生成覆盖率报告
make test-cov

# 查看 HTML 报告
open htmlcov/index.html  # macOS
start htmlcov/index.html # Windows
```

### 测试脚本使用

测试脚本提供了最简单的方式来运行测试：

```bash
# Windows
scripts\run-tests.bat [test_type]

# Linux/macOS
bash scripts/run-tests.sh [test_type]
```

**可用的测试类型**:
- `all` - 运行所有测试（默认）
- `unit` - 单元测试
- `integration` - 集成测试
- `api` - API 测试
- `database` - 数据库测试
- `security` - 安全测试
- `performance` - 性能测试
- `coverage` - 带覆盖率的测试
- `parallel` - 并行测试
- `html` - 生成 HTML 报告
- `quick` - 快速测试（排除慢速测试）
- `slow` - 仅慢速测试

### Make 命令

```bash
make test              # 运行所有测试
make test-unit         # 单元测试
make test-integration  # 集成测试
make test-api          # API 测试
make test-db           # 数据库测试
make test-security     # 安全测试
make test-performance  # 性能测试
make test-cov          # 覆盖率测试
make test-html         # HTML 报告
make test-parallel     # 并行测试
make test-watch        # 监控文件变化自动测试
```

### pytest 命令详解

```bash
# 基本用法
pytest tests/ -v

# 运行特定文件
pytest tests/test_api_endpoints.py -v

# 运行特定测试
pytest tests/test_api_endpoints.py::test_login -v

# 使用标记
pytest tests/ -m "unit" -v
pytest tests/ -m "not slow" -v
pytest tests/ -m "api and not slow" -v

# 并行运行
pytest tests/ -n auto
pytest tests/ -n 4  # 使用4个进程

# 覆盖率报告
pytest tests/ --cov=app --cov-report=html
pytest tests/ --cov=app --cov-report=xml --cov-report=term-missing

# 详细输出
pytest tests/ -v --tb=long
pytest tests/ -v -s  # 显示print输出

# 调试选项
pytest tests/ --pdb  # 失败时进入调试器
pytest tests/ -x     # 停止在第一个失败
pytest tests/ --lf   # 重新运行失败的测试
pytest tests/ --ff   # 先运行失败的测试

# 性能分析
pytest tests/ --durations=10  # 显示最慢的10个测试
pytest tests/ --benchmark-only  # 只运行基准测试

# 生成报告
pytest tests/ --html=reports/report.html --self-contained-html
pytest tests/ --junitxml=reports/junit.xml
```

## 测试配置

### 测试夹具 (Fixtures)

主要的测试夹具包括：

#### 应用和客户端夹具
```python
@pytest.fixture
def app():
    """测试应用实例"""
    from app.main import create_app
    app = create_app(testing=True)
    return app

@pytest.fixture
def client(app):
    """测试客户端"""
    return TestClient(app)

@pytest.fixture
async def async_client(app):
    """异步测试客户端"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
```

#### 数据库夹具
```python
@pytest.fixture
def db_session():
    """数据库会话"""
    from app.core.database import get_db_session
    session = next(get_db_session())
    try:
        yield session
    finally:
        session.rollback()
        session.close()
```

#### 用户和认证夹具
```python
@pytest.fixture
def admin_user(db_session):
    """管理员用户"""
    user = User(
        username="admin",
        email="admin@example.com",
        is_superuser=True
    )
    user.set_password("admin123")
    db_session.add(user)
    db_session.commit()
    return user

@pytest.fixture
def auth_headers(admin_user):
    """认证头部"""
    from app.utils.jwt_utils import create_access_token
    token = create_access_token(data={"sub": admin_user.username})
    return {"Authorization": f"Bearer {token}"}
```

### 测试数据库配置

- **开发/CI**: PostgreSQL
- **本地测试**: SQLite (内存数据库)
- **TDengine**: 模拟连接器

### 模拟服务配置

```python
@pytest.fixture
def mock_redis():
    """模拟Redis连接"""
    from unittest.mock import AsyncMock
    redis_mock = AsyncMock()
    redis_mock.get.return_value = None
    redis_mock.set.return_value = True
    return redis_mock

@pytest.fixture
def mock_email_service():
    """模拟邮件服务"""
    from unittest.mock import Mock
    email_mock = Mock()
    email_mock.send_email.return_value = True
    return email_mock
```

## CI/CD 集成

### GitHub Actions 配置

项目配置了 GitHub Actions 工作流 (`.github/workflows/test.yml`)，包括：

#### 多环境测试矩阵
- **操作系统**: Ubuntu, Windows, macOS
- **Python 版本**: 3.9, 3.10, 3.11, 3.12
- **数据库**: PostgreSQL 15, Redis 7

#### 测试流程
1. **环境准备**: 设置Python环境，启动服务
2. **依赖安装**: 安装项目和测试依赖
3. **代码质量检查**: linting, type checking, security
4. **测试执行**: 分类运行各种测试
5. **覆盖率报告**: 生成并上传覆盖率报告
6. **性能测试**: 基准测试和性能分析
7. **Docker测试**: 容器化测试

#### 工作流示例
```yaml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        python-version: ['3.10', '3.11']
    
    steps:
    - uses: actions/checkout@v4
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: Run tests
      run: |
        pytest tests/ --cov=app --cov-report=xml
```

### 本地 CI 模拟

```bash
# 运行完整的质量检查
make check-all

# 运行质量检查
make quality

# 准备发布
make prepare-release
```

### 覆盖率集成

- **Codecov**: 自动上传覆盖率报告
- **本地报告**: HTML和XML格式
- **覆盖率门槛**: 设置最低覆盖率要求

## 测试开发指南

### 测试文件命名规范

- 测试文件以 `test_` 开头
- 测试函数以 `test_` 开头
- 测试类以 `Test` 开头
- 文件名应该反映被测试的模块

### 测试标记使用

```python
import pytest

# 基本标记
@pytest.mark.unit
def test_basic_function():
    """单元测试示例"""
    pass

@pytest.mark.api
@pytest.mark.asyncio
async def test_api_endpoint(async_client):
    """API 测试示例"""
    response = await async_client.get("/api/health")
    assert response.status_code == 200

@pytest.mark.database
def test_database_operation(db_session):
    """数据库测试示例"""
    pass

@pytest.mark.integration
@pytest.mark.slow
def test_complex_workflow():
    """集成测试示例"""
    pass

@pytest.mark.performance
def test_performance_benchmark(benchmark):
    """性能测试示例"""
    result = benchmark(some_function)
    assert result is not None

@pytest.mark.security
def test_security_feature():
    """安全测试示例"""
    pass

# 组合标记
@pytest.mark.api
@pytest.mark.security
def test_api_security():
    """API安全测试"""
    pass
```

### 夹具使用最佳实践

```python
# 使用现有夹具
def test_with_user(admin_user, db_session):
    """使用用户夹具的测试"""
    assert admin_user.username == "admin"
    assert admin_user.is_active is True

# 组合多个夹具
async def test_with_auth(async_client, auth_headers, test_department):
    """使用认证和部门夹具的测试"""
    response = await async_client.get(
        "/api/users/me",
        headers=auth_headers
    )
    assert response.status_code == 200

# 参数化测试
@pytest.mark.parametrize("username,email,expected", [
    ("user1", "user1@example.com", True),
    ("user2", "invalid-email", False),
    ("", "user3@example.com", False),
])
def test_user_validation(username, email, expected):
    """参数化用户验证测试"""
    result = validate_user_data(username, email)
    assert result == expected
```

### 模拟外部依赖

```python
from unittest.mock import patch, MagicMock, AsyncMock

# 模拟同步函数
@patch('app.services.email.send_email')
def test_email_sending(mock_send_email):
    """模拟邮件发送"""
    mock_send_email.return_value = True
    # 测试代码
    result = send_notification("test@example.com", "Test")
    assert result is True
    mock_send_email.assert_called_once()

# 模拟异步函数
@pytest.mark.asyncio
@patch('app.services.external_api.fetch_data')
async def test_external_api(mock_fetch):
    """模拟外部API调用"""
    mock_fetch.return_value = {"status": "success"}
    result = await process_external_data()
    assert result["status"] == "success"

# 使用夹具模拟
@pytest.mark.asyncio
async def test_with_mock_redis(mock_redis):
    """使用模拟 Redis"""
    await mock_redis.set("key", "value")
    value = await mock_redis.get("key")
    assert value == "value"

# 模拟类和方法
@patch('app.core.tdengine_connector.TDengineConnector')
def test_tdengine_operations(mock_connector_class):
    """模拟TDengine连接器"""
    mock_instance = MagicMock()
    mock_connector_class.return_value = mock_instance
    mock_instance.execute.return_value = [{"count": 100}]
    
    connector = TDengineConnector()
    result = connector.execute("SELECT COUNT(*) FROM devices")
    assert result[0]["count"] == 100
```

### 异步测试编写

```python
@pytest.mark.asyncio
class TestAsyncOperations:
    """异步操作测试"""
    
    async def test_async_database_operation(self, async_db_session):
        """异步数据库操作测试"""
        user = User(username="async_user")
        async_db_session.add(user)
        await async_db_session.commit()
        
        result = await async_db_session.get(User, user.id)
        assert result.username == "async_user"
    
    async def test_concurrent_api_calls(self, async_client, auth_headers):
        """并发API调用测试"""
        import asyncio
        
        async def make_request(endpoint):
            return await async_client.get(endpoint, headers=auth_headers)
        
        # 并发调用多个端点
        tasks = [
            make_request("/api/users"),
            make_request("/api/departments"),
            make_request("/api/roles")
        ]
        
        responses = await asyncio.gather(*tasks)
        assert all(r.status_code == 200 for r in responses)
```

## 质量保证

### 代码覆盖率

#### 覆盖率配置 (.coveragerc)
```ini
[run]
source = app
omit = 
    app/tests/*
    app/migrations/*
    */venv/*
    */virtualenv/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError

[html]
directory = htmlcov
```

#### 覆盖率目标
- **总体覆盖率**: ≥ 85%
- **核心模块覆盖率**: ≥ 90%
- **API端点覆盖率**: 100%
- **关键业务逻辑覆盖率**: 100%

#### 覆盖率报告
```bash
# 生成覆盖率报告
pytest tests/ --cov=app --cov-report=html --cov-report=xml --cov-report=term-missing

# 查看详细报告
open htmlcov/index.html

# 检查覆盖率是否达标
pytest tests/ --cov=app --cov-fail-under=85
```

### 代码质量检查

#### Linting 检查
```bash
# 代码风格检查
ruff check app/ tests/
black --check app/ tests/
isort --check-only app/ tests/

# 自动修复
black app/ tests/
isort app/ tests/
ruff check --fix app/ tests/
```

#### 类型检查
```bash
# 静态类型检查
mypy app/

# 配置文件 (pyproject.toml)
[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

#### 安全检查
```bash
# 安全漏洞扫描
bandit -r app/
safety check

# 依赖安全检查
pip-audit
```

### 性能监控

#### 性能基准
```python
@pytest.mark.performance
def test_api_response_time(benchmark, async_client):
    """API响应时间基准测试"""
    async def api_call():
        return await async_client.get("/api/users")
    
    result = benchmark(api_call)
    # 断言响应时间小于100ms
    assert benchmark.stats.mean < 0.1
```

#### 内存使用监控
```python
@pytest.mark.performance
def test_memory_usage():
    """内存使用测试"""
    import psutil
    import os
    
    process = psutil.Process(os.getpid())
    initial_memory = process.memory_info().rss
    
    # 执行操作
    perform_memory_intensive_operation()
    
    final_memory = process.memory_info().rss
    memory_increase = final_memory - initial_memory
    
    # 断言内存增长不超过100MB
    assert memory_increase < 100 * 1024 * 1024
```

## 故障排除

### 常见问题及解决方案

#### 1. 导入错误

**问题**: `ModuleNotFoundError: No module named 'app'`

**解决方案**:
```bash
# 方法1: 设置PYTHONPATH
export PYTHONPATH="${PYTHONPATH}:$(pwd)"

# 方法2: 安装为可编辑包
pip install -e .

# 方法3: 在pytest.ini中配置
[tool:pytest]
python_paths = .
```

#### 2. 数据库连接错误

**问题**: `sqlalchemy.exc.OperationalError: could not connect to server`

**解决方案**:
```bash
# 检查数据库服务状态
pg_isready -h localhost -p 5432

# 检查环境变量
echo $DATABASE_URL

# 启动数据库服务
# Windows
net start postgresql

# Linux/macOS
sudo systemctl start postgresql
# 或
brew services start postgresql
```

#### 3. Redis 连接错误

**问题**: `redis.exceptions.ConnectionError: Error connecting to Redis`

**解决方案**:
```bash
# 检查Redis服务
redis-cli ping

# 启动Redis服务
# Windows
redis-server

# Linux/macOS
sudo systemctl start redis
# 或
brew services start redis
```

#### 4. 权限错误

**问题**: `PermissionError: [Errno 13] Permission denied`

**解决方案**:
```bash
# 确保测试目录有写权限
chmod -R 755 tests/
mkdir -p tests/logs tests/temp reports

# Windows
icacls tests /grant Everyone:F /T
```

#### 5. 测试超时

**问题**: 测试运行时间过长或超时

**解决方案**:
```python
# 设置测试超时
@pytest.mark.timeout(30)
def test_slow_operation():
    pass

# 或在pytest.ini中全局设置
[tool:pytest]
timeout = 300
```

### 调试技巧

#### 详细输出调试
```bash
# 显示详细输出
pytest tests/ -v -s

# 显示本地变量
pytest tests/ --tb=long

# 显示完整的错误堆栈
pytest tests/ --tb=line
```

#### 交互式调试
```bash
# 失败时进入调试器
pytest tests/ --pdb

# 在特定点设置断点
# 在代码中添加:
import pdb; pdb.set_trace()
```

#### 选择性运行
```bash
# 只运行失败的测试
pytest tests/ --lf

# 先运行失败的测试
pytest tests/ --ff

# 运行到第一个失败就停止
pytest tests/ -x

# 运行特定测试
pytest tests/test_api.py::test_login -v
```

#### 性能调试
```bash
# 显示最慢的测试
pytest tests/ --durations=10

# 性能分析
pytest tests/ --profile

# 内存使用分析
pytest tests/ --memray
```

#### 日志调试

测试日志保存在 `tests/logs/` 目录中：

```bash
# 查看pytest日志
tail -f tests/logs/pytest.log

# 查看应用日志
tail -f tests/logs/app.log

# 查看错误日志
tail -f tests/logs/error.log

# Windows
Get-Content tests\logs\pytest.log -Wait
```

#### 环境调试
```bash
# 检查Python环境
python --version
which python

# 检查已安装的包
pip list
pip show pytest

# 检查环境变量
env | grep -E '(DATABASE|REDIS|SECRET)'

# Windows
set | findstr /I "DATABASE REDIS SECRET"
```

## 最佳实践

### 1. 测试设计原则

#### 测试隔离
- 每个测试应该独立运行，不依赖其他测试
- 使用事务回滚清理数据
- 避免全局状态的修改
- 使用独立的测试数据

```python
# 好的做法
def test_user_creation(db_session):
    user = User(username="test")
    db_session.add(user)
    db_session.commit()
    assert user.id is not None
    # 测试结束后自动回滚

# 避免的做法
global_user = None

def test_create_global_user():
    global global_user
    global_user = User(username="test")
    # 依赖全局状态

def test_use_global_user():
    assert global_user.username == "test"
    # 依赖前一个测试
```

#### 测试数据管理
- 使用夹具创建测试数据
- 避免硬编码数据
- 使用工厂模式生成数据
- 保持测试数据的最小化

```python
# 使用工厂模式
class UserFactory:
    @staticmethod
    def create(username=None, email=None, **kwargs):
        return User(
            username=username or f"user_{uuid.uuid4().hex[:8]}",
            email=email or f"user_{uuid.uuid4().hex[:8]}@example.com",
            **kwargs
        )

# 在测试中使用
def test_user_operations():
    user1 = UserFactory.create(username="specific_user")
    user2 = UserFactory.create()  # 自动生成唯一数据
```

#### 断言最佳实践
- 使用描述性的断言消息
- 测试预期的行为和边界情况
- 避免过于复杂的断言
- 一个测试一个断言（理想情况）

```python
# 好的断言
def test_user_creation():
    user = create_user("testuser", "test@example.com")
    assert user.username == "testuser", "用户名应该正确设置"
    assert user.email == "test@example.com", "邮箱应该正确设置"
    assert user.is_active is True, "新用户应该默认激活"
    assert user.created_at is not None, "创建时间应该被设置"

# 避免复杂断言
def test_user_creation_bad():
    user = create_user("testuser", "test@example.com")
    assert (
        user.username == "testuser" and 
        user.email == "test@example.com" and 
        user.is_active and 
        user.created_at
    ), "用户创建失败"  # 难以定位具体问题
```

### 2. 性能优化

#### 测试执行优化
- 标记慢速测试，分离执行
- 使用并行执行提高速度
- 优化测试数据库操作
- 合理使用模拟对象

```python
# 标记慢速测试
@pytest.mark.slow
def test_large_data_processing():
    # 处理大量数据的测试
    pass

# 并行执行
# pytest tests/ -n auto

# 数据库操作优化
@pytest.fixture(scope="session")
def db_setup():
    # 会话级别的数据库设置
    setup_test_database()
    yield
    cleanup_test_database()
```

#### 资源管理
- 及时清理临时文件
- 合理管理数据库连接
- 避免内存泄漏

```python
@pytest.fixture
def temp_file():
    import tempfile
    import os
    
    fd, path = tempfile.mkstemp()
    try:
        yield path
    finally:
        os.close(fd)
        os.unlink(path)
```

### 3. 维护性

#### 代码组织
- 保持测试代码的清洁
- 使用有意义的测试名称
- 适当的注释和文档
- 遵循项目的编码规范

```python
class TestUserAuthentication:
    """用户认证相关测试"""
    
    def test_login_with_valid_credentials_returns_token(self, client):
        """测试使用有效凭据登录应该返回访问令牌"""
        # Arrange
        user_data = {"username": "testuser", "password": "password123"}
        
        # Act
        response = client.post("/api/auth/login", json=user_data)
        
        # Assert
        assert response.status_code == 200
        assert "access_token" in response.json()
    
    def test_login_with_invalid_credentials_returns_unauthorized(self, client):
        """测试使用无效凭据登录应该返回401错误"""
        # Arrange
        invalid_data = {"username": "invalid", "password": "wrong"}
        
        # Act
        response = client.post("/api/auth/login", json=invalid_data)
        
        # Assert
        assert response.status_code == 401
        assert "access_token" not in response.json()
```

#### 持续改进
- 定期更新测试依赖
- 监控测试执行时间
- 及时修复失败的测试
- 定期审查测试覆盖率

```bash
# 定期更新依赖
pip list --outdated
pip install -U pytest pytest-cov

# 监控测试性能
pytest tests/ --durations=0 > test_durations.log

# 检查测试覆盖率趋势
pytest tests/ --cov=app --cov-report=json
```

### 4. 团队协作

#### 测试规范
- 建立团队测试标准
- 代码审查包含测试
- 共享测试工具和夹具
- 文档化测试策略

#### 知识分享
- 定期分享测试最佳实践
- 培训新团队成员
- 建立测试问题解决知识库

## 参考资源

### 官方文档
- [pytest 官方文档](https://docs.pytest.org/)
- [pytest-asyncio 文档](https://pytest-asyncio.readthedocs.io/)
- [pytest-cov 文档](https://pytest-cov.readthedocs.io/)
- [FastAPI 测试文档](https://fastapi.tiangolo.com/tutorial/testing/)
- [SQLAlchemy 测试文档](https://docs.sqlalchemy.org/en/14/orm/session_transaction.html)

### 测试工具
- [pytest-benchmark](https://pytest-benchmark.readthedocs.io/) - 性能基准测试
- [pytest-xdist](https://pytest-xdist.readthedocs.io/) - 并行测试执行
- [pytest-mock](https://pytest-mock.readthedocs.io/) - 模拟对象
- [pytest-html](https://pytest-html.readthedocs.io/) - HTML测试报告
- [pytest-timeout](https://pytest-timeout.readthedocs.io/) - 测试超时控制

### 最佳实践指南
- [Python Testing Best Practices](https://docs.python-guide.org/writing/tests/)
- [Test-Driven Development](https://testdriven.io/)
- [Clean Code Testing Principles](https://clean-code-developer.com/)

### 社区资源
- [pytest 插件列表](https://plugincompat.herokuapp.com/)
- [Python Testing Community](https://www.python.org/community/sigs/current/testing-in-python/)
- [Stack Overflow pytest 标签](https://stackoverflow.com/questions/tagged/pytest)

---

**文档版本**: v1.0  
**最后更新**: 2024年12月  
**维护者**: DeviceMonitor 开发团队